    <script>
        // Initialize Icons
        if (window.lucide) {
            lucide.createIcons();
        }

        // --- Circle the Cat Game Logic ---
        (function() {
            const canvas = document.getElementById('cat-game');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const resetButton = document.getElementById('reset-game');
            const switchRoleButton = document.getElementById('switch-role');
            const roleText = document.getElementById('role-text');
            const instructionText = document.getElementById('game-instruction');
            const messageEl = document.getElementById('game-message');
            const messageText = messageEl.querySelector('span');

            const GRID_SIZE = 11;
            const RADIUS = 14;
            const GAP = 5;
            let dots = [];
            let catPos = { x: 5, y: 5 };
            let gameState = 'playing'; // playing, win, lose
            let playerRole = 'catcher'; // 'catcher' | 'cat'
            let isAiTurn = false;

            // Initialize Game
            function initGame() {
                dots = [];
                catPos = { x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2) };
                gameState = 'playing';
                isAiTurn = false;
                hideMessage();

                // Create grid
                for (let y = 0; y < GRID_SIZE; y++) {
                    let row = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        // Random blocks (10-15%)
                        const isBlocked = (Math.random() < 0.12) && (x !== catPos.x || y !== catPos.y);
                        row.push({ x, y, blocked: isBlocked });
                    }
                    dots.push(row);
                }
                
                updateUI();
                resize();
                requestAnimationFrame(draw);
            }

            function updateUI() {
                if (playerRole === 'catcher') {
                    instructionText.textContent = "点击背景围住小猫，别让它跑掉！";
                    roleText.textContent = "切换: 扮演小猫";
                    switchRoleButton.className = switchRoleButton.className.replace('text-pink-600', 'text-purple-600').replace('bg-pink-50', 'bg-purple-50');
                } else {
                    instructionText.textContent = "点击相邻格子移动小猫，逃离抓捕！";
                    roleText.textContent = "切换: 扮演抓捕者";
                    switchRoleButton.className = switchRoleButton.className.replace('text-purple-600', 'text-pink-600').replace('bg-purple-50', 'bg-pink-50');
                }
                // Re-render icons if needed (Lucide handles this automatically usually, but we might need to trigger it if we changed innerHTML)
            }

            function switchRole() {
                playerRole = playerRole === 'catcher' ? 'cat' : 'catcher';
                initGame();
            }

            function resize() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                
                const contentWidth = GRID_SIZE * (RADIUS * 2 + GAP) + RADIUS;
                const scale = canvas.width / (contentWidth + 40);
                
                ctx.setTransform(scale, 0, 0, scale, 20, 20);
            }

            function draw() {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();

                const isDark = document.documentElement.classList.contains('dark');
                const dotColor = isDark ? '#374151' : '#e5e7eb';
                const blockedColor = isDark ? '#9ca3af' : '#6b7280';
                const catColor = playerRole === 'cat' ? '#ec4899' : '#ef4444'; // Pink if player is cat, Red otherwise

                // Draw Dots
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const dot = dots[y][x];
                        const px = getPixelPos(x, y);
                        
                        ctx.beginPath();
                        ctx.arc(px.x, px.y, RADIUS, 0, Math.PI * 2);
                        ctx.fillStyle = dot.blocked ? blockedColor : dotColor;
                        ctx.fill();
                        ctx.closePath();
                    }
                }

                // Highlight valid moves for Player Cat
                if (playerRole === 'cat' && gameState === 'playing' && !isAiTurn) {
                    const neighbors = getNeighbors(catPos.x, catPos.y);
                    for (let n of neighbors) {
                        if (!dots[n.y][n.x].blocked) {
                            const px = getPixelPos(n.x, n.y);
                            ctx.beginPath();
                            ctx.arc(px.x, px.y, RADIUS, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(236, 72, 153, 0.4)'; // Pink Highlight
                            ctx.fill();
                        }
                    }
                }

                // Draw Cat
                const catPx = getPixelPos(catPos.x, catPos.y);
                ctx.beginPath();
                ctx.arc(catPx.x, catPx.y, RADIUS * 0.8, 0, Math.PI * 2);
                ctx.fillStyle = catColor;
                ctx.fill();
                
                // Draw Cat Face
                ctx.fillStyle = 'white';
                ctx.beginPath(); ctx.arc(catPx.x - 4, catPx.y - 2, 2.5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(catPx.x + 4, catPx.y - 2, 2.5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(catPx.x, catPx.y + 2, 1.5, 0, Math.PI * 2); ctx.fill();
            }

            function getPixelPos(x, y) {
                const offsetX = (y % 2) * (RADIUS + GAP / 2);
                const px = x * (RADIUS * 2 + GAP) + offsetX;
                const py = y * (RADIUS * 2 + GAP) * 0.866;
                return { x: px, y: py };
            }

            function getGridPos(clickX, clickY) {
                const contentWidth = GRID_SIZE * (RADIUS * 2 + GAP) + RADIUS;
                const scale = canvas.width / (contentWidth + 40);
                
                const relativeX = (clickX - 20) / scale;
                const relativeY = (clickY - 20) / scale;

                let minDist = Infinity;
                let closest = null;

                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const px = getPixelPos(x, y);
                        const dist = Math.sqrt((px.x - relativeX) ** 2 + (px.y - relativeY) ** 2);
                        if (dist < RADIUS + 2 && dist < minDist) {
                            minDist = dist;
                            closest = { x, y };
                        }
                    }
                }
                return closest;
            }

            function getNeighbors(x, y) {
                const neighbors = [];
                const isOdd = y % 2 !== 0;
                const directions = isOdd ? 
                    [[0, -1], [1, -1], [-1, 0], [1, 0], [0, 1], [1, 1]] :
                    [[-1, -1], [0, -1], [-1, 0], [1, 0], [-1, 1], [0, 1]];

                for (let dir of directions) {
                    const nx = x + dir[0];
                    const ny = y + dir[1];
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                        neighbors.push({ x: nx, y: ny });
                    }
                }
                return neighbors;
            }

            function findShortestPath(start) {
                const queue = [{ x: start.x, y: start.y, path: [] }];
                const visited = new Set();
                visited.add(`${start.x},${start.y}`);

                while (queue.length > 0) {
                    const { x, y, path } = queue.shift();

                    if (x === 0 || x === GRID_SIZE - 1 || y === 0 || y === GRID_SIZE - 1) {
                        return path;
                    }

                    const neighbors = getNeighbors(x, y);
                    for (let n of neighbors) {
                        if (!dots[n.y][n.x].blocked && !visited.has(`${n.x},${n.y}`)) {
                            visited.add(`${n.x},${n.y}`);
                            queue.push({ x: n.x, y: n.y, path: [...path, { x: n.x, y: n.y }] });
                        }
                    }
                }
                return null;
            }

            // --- AI Logic ---

            function aiMoveCat() {
                const path = findShortestPath(catPos);
                
                if (path && path.length > 0) {
                    catPos = path[0];
                    if (isEdge(catPos)) {
                        endGame('cat_win');
                    }
                } else {
                    // No path to edge, move randomly to prolong
                    const neighbors = getNeighbors(catPos.x, catPos.y);
                    const available = neighbors.filter(n => !dots[n.y][n.x].blocked);
                    
                    if (available.length === 0) {
                        endGame('catcher_win');
                    } else {
                        const randomMove = available[Math.floor(Math.random() * available.length)];
                        catPos = randomMove;
                    }
                }
                draw();
                isAiTurn = false;
            }

            function aiPlaceBlock() {
                const path = findShortestPath(catPos);
                let blockTarget = null;

                if (path && path.length > 0) {
                    // Smart Block: Block the immediate next step
                    // This is simple but effective
                    blockTarget = path[0];
                } else {
                    // Cat is trapped, just fill random available spots to finish it
                    // Or try to block neighbors of cat
                    const neighbors = getNeighbors(catPos.x, catPos.y);
                    const available = neighbors.filter(n => !dots[n.y][n.x].blocked);
                    if (available.length > 0) {
                        blockTarget = available[Math.floor(Math.random() * available.length)];
                    } else {
                        // All blocked, wait for win check
                    }
                }

                if (blockTarget && !dots[blockTarget.y][blockTarget.x].blocked) {
                    dots[blockTarget.y][blockTarget.x].blocked = true;
                    // Check if cat is now completely trapped (no moves)
                    const neighbors = getNeighbors(catPos.x, catPos.y);
                    const available = neighbors.filter(n => !dots[n.y][n.x].blocked);
                    if (available.length === 0) {
                        endGame('catcher_win');
                    }
                }
                draw();
                isAiTurn = false;
            }

            function isEdge(pos) {
                return pos.x === 0 || pos.x === GRID_SIZE - 1 || pos.y === 0 || pos.y === GRID_SIZE - 1;
            }

            function endGame(result) {
                gameState = result === 'cat_win' ? 'lose' : 'win'; // Default perspective (Catcher)
                
                if (playerRole === 'catcher') {
                    if (result === 'cat_win') {
                        showMessage('小猫跑掉了！', 'bg-red-500');
                        gameState = 'lose';
                    } else {
                        showMessage('你抓住了小猫！', 'bg-green-500');
                        gameState = 'win';
                    }
                } else {
                    // Player is Cat
                    if (result === 'cat_win') {
                        showMessage('你逃脱了！', 'bg-green-500');
                        gameState = 'win';
                    } else {
                        showMessage('你被抓住了！', 'bg-red-500');
                        gameState = 'lose';
                    }
                }
            }

            function showMessage(text, colorClass) {
                messageText.textContent = text;
                // Reset classes
                messageText.className = `text-white font-bold text-xl px-6 py-3 rounded-full shadow-lg transform transition-transform duration-300 ${colorClass}`;
                messageEl.classList.remove('opacity-0', 'pointer-events-none');
                messageEl.querySelector('span').classList.remove('scale-0');
                messageEl.querySelector('span').classList.add('scale-100');
            }

            function hideMessage() {
                messageEl.classList.add('opacity-0', 'pointer-events-none');
                messageEl.querySelector('span').classList.add('scale-0');
                messageEl.querySelector('span').classList.remove('scale-100');
            }

            // Input Handling
            canvas.addEventListener('click', (e) => {
                if (gameState !== 'playing' || isAiTurn) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const gridPos = getGridPos(x, y);
                if (!gridPos) return;

                if (playerRole === 'catcher') {
                    const dot = dots[gridPos.y][gridPos.x];
                    if (!dot.blocked && (gridPos.x !== catPos.x || gridPos.y !== catPos.y)) {
                        dot.blocked = true;
                        draw();
                        
                        // Check if blocking caused instant win (rare but possible)
                        const neighbors = getNeighbors(catPos.x, catPos.y);
                        const available = neighbors.filter(n => !dots[n.y][n.x].blocked);
                        if (available.length === 0) {
                            endGame('catcher_win');
                        } else {
                            isAiTurn = true;
                            setTimeout(aiMoveCat, 200);
                        }
                    }
                } else {
                    // Player is Cat
                    // Check if clicked tile is neighbor and not blocked
                    const neighbors = getNeighbors(catPos.x, catPos.y);
                    const isNeighbor = neighbors.some(n => n.x === gridPos.x && n.y === gridPos.y);
                    const dot = dots[gridPos.y][gridPos.x];

                    if (isNeighbor && !dot.blocked) {
                        catPos = gridPos;
                        draw();

                        if (isEdge(catPos)) {
                            endGame('cat_win');
                        } else {
                            isAiTurn = true;
                            setTimeout(aiPlaceBlock, 200);
                        }
                    }
                }
            });

            resetButton.addEventListener('click', initGame);
            switchRoleButton.addEventListener('click', switchRole);
            
            window.addEventListener('resize', () => {
                resize();
                draw();
            });

            // Start
            initGame();
        })();
    </script>
