<!DOCTYPE html>
<html lang="zh-CN" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404 - 页面未找到 | 夏日科技探索</title>
    <link rel="icon" type="image/png" href="public/img/favicon256.png">
    
    <!-- Tailwind CSS -->
    <link href="css/style.css" rel="stylesheet">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.loli.net">
    <link rel="preconnect" href="https://gstatic.loli.net" crossorigin>
    <link href="https://fonts.loli.net/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Lucide Icons -->
    <script src="https://cdn.jsdelivr.net/npm/lucide@latest/dist/umd/lucide.min.js"></script>

    <style>
        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-black text-gray-900 dark:text-gray-100 font-sans transition-colors duration-500 flex flex-col min-h-screen">

    <!-- Navbar -->
    <nav id="navbar" class="fixed w-full z-50 top-0 transition-all duration-300 bg-white/80 dark:bg-black/80 backdrop-blur-md border-b border-gray-100 dark:border-gray-800">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <a href="index.html" class="flex items-center group">
                        <div class="relative">
                            <div class="absolute -inset-1 bg-gradient-to-r from-blue-600 to-indigo-600 rounded-full blur opacity-25 group-hover:opacity-50 transition duration-200"></div>
                            <img src="public/img/favicon256.png" alt="Logo" class="relative h-8 w-8 mr-2 dark:hidden">
                            <img src="public/img/black256.png" alt="Logo" class="relative h-8 w-8 mr-2 hidden dark:block">
                        </div>
                        <span class="font-bold text-xl tracking-tight transition-colors duration-300">
                            夏日科技探索
                        </span>
                    </a>
                </div>
                
                <div class="hidden lg:flex items-center space-x-1">
                    <a href="index.html" class="nav-link px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 text-gray-600 hover:text-blue-600 hover:bg-gray-50 dark:text-gray-300 dark:hover:text-white dark:hover:bg-white/10">首页</a>
                    <a href="blog.html" class="nav-link px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 text-gray-600 hover:text-blue-600 hover:bg-gray-50 dark:text-gray-300 dark:hover:text-white dark:hover:bg-white/10">星空笔记</a>
                    <a href="moments.html" class="nav-link px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 text-gray-600 hover:text-blue-600 hover:bg-gray-50 dark:text-gray-300 dark:hover:text-white dark:hover:bg-white/10">随手拍</a>
                    <a href="bookmarks.html" class="nav-link px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 text-gray-600 hover:text-blue-600 hover:bg-gray-50 dark:text-gray-300 dark:hover:text-white dark:hover:bg-white/10">收藏</a>
                    <a href="about.html" class="nav-link px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 text-gray-600 hover:text-blue-600 hover:bg-gray-50 dark:text-gray-300 dark:hover:text-white dark:hover:bg-white/10">关于</a>
                    
                    <button id="theme-toggle" class="ml-4 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors">
                        <i data-lucide="moon" class="w-5 h-5 text-gray-600 dark:text-gray-300"></i>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="flex-grow flex flex-col items-center justify-center px-4 pt-24 pb-12 relative z-10">
        <h1 class="text-8xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600 mb-2">404</h1>
        <p class="text-xl text-gray-600 dark:text-gray-400 mb-8 font-serif italic">Oops! The page you're looking for has vanished into the void.</p>
        
        <!-- Game Container -->
        <div class="relative bg-white dark:bg-gray-800 rounded-2xl shadow-xl p-6 max-w-lg w-full border border-gray-100 dark:border-gray-700">
             <div class="flex justify-between items-center mb-4">
                 <span id="role-text" class="text-sm font-medium text-gray-500 dark:text-gray-400">切换: 扮演小猫</span>
                 <div class="flex space-x-2">
                     <button id="switch-role" class="px-3 py-1 text-xs sm:text-sm rounded-full bg-purple-50 text-purple-600 font-medium transition-colors hover:bg-purple-100">Switch Role</button>
                     <button id="reset-game" class="px-3 py-1 text-xs sm:text-sm rounded-full bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-300 font-medium transition-colors hover:bg-gray-200 dark:hover:bg-gray-600">Reset</button>
                 </div>
             </div>
             
             <p id="game-instruction" class="text-center text-gray-700 dark:text-gray-300 font-medium mb-4 text-sm sm:text-base">点击背景围住小猫，别让它跑掉！</p>
             
             <div class="relative aspect-square w-full bg-gray-50 dark:bg-gray-900 rounded-xl overflow-hidden cursor-pointer touch-none select-none">
                  <canvas id="cat-game" class="w-full h-full"></canvas>
                  
                  <!-- Message Overlay -->
                  <div id="game-message" class="absolute inset-0 flex items-center justify-center pointer-events-none opacity-0 transition-opacity duration-300 z-10">
                      <span class="text-white font-bold text-xl px-6 py-3 rounded-full shadow-lg transform scale-0 transition-transform duration-300"></span>
                  </div>
             </div>
        </div>
        
        <a href="index.html" class="mt-8 px-8 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-full font-medium transition-all shadow-lg shadow-blue-500/30 hover:shadow-blue-500/50 flex items-center group">
            <i data-lucide="arrow-left" class="w-4 h-4 mr-2 group-hover:-translate-x-1 transition-transform"></i>
            Return Home
        </a>
    </main>

    <!-- Standardized Footer -->
    
    <footer class="py-8 text-center z-20 transition-all duration-500 relative">
    <p class="text-[10px] sm:text-xs tracking-widest uppercase text-gray-400 dark:text-gray-500 opacity-60">
        &copy; <span id="year"></span> ShadowQuake <span class="mx-2 text-blue-500">|</span> Designed with <span class="text-red-500 animate-pulse">❤️</span>
    </p>
</footer>


    <!-- Scripts -->
    <script src="js/main.js"></script>
    <script>
        // Initialize Icons
        lucide.createIcons();
        
        // Dynamic Year
        document.getElementById('year').textContent = new Date().getFullYear();

        // --- Circle the Cat Game Logic ---
        (function() {
            const canvas = document.getElementById('cat-game');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const resetButton = document.getElementById('reset-game');
            const switchRoleButton = document.getElementById('switch-role');
            const roleText = document.getElementById('role-text');
            const instructionText = document.getElementById('game-instruction');
            const messageEl = document.getElementById('game-message');
            const messageText = messageEl.querySelector('span');

            const GRID_SIZE = 11;
            const RADIUS = 14;
            const GAP = 5;
            let dots = [];
            let catPos = { x: 5, y: 5 };
            let gameState = 'playing'; // playing, win, lose
            let playerRole = 'catcher'; // 'catcher' | 'cat'
            let isAiTurn = false;

            // Initialize Game
            function initGame() {
                dots = [];
                catPos = { x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2) };
                gameState = 'playing';
                isAiTurn = false;
                hideMessage();

                // Create grid
                for (let y = 0; y < GRID_SIZE; y++) {
                    let row = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        // Random blocks (10-15%)
                        const isBlocked = (Math.random() < 0.12) && (x !== catPos.x || y !== catPos.y);
                        row.push({ x, y, blocked: isBlocked });
                    }
                    dots.push(row);
                }
                
                updateUI();
                resize();
                requestAnimationFrame(draw);
            }

            function updateUI() {
                if (playerRole === 'catcher') {
                    instructionText.textContent = "点击背景围住小猫，别让它跑掉！";
                    roleText.textContent = "切换: 扮演小猫";
                    switchRoleButton.className = switchRoleButton.className.replace('text-pink-600', 'text-purple-600').replace('bg-pink-50', 'bg-purple-50');
                } else {
                    instructionText.textContent = "点击相邻格子移动小猫，逃离抓捕！";
                    roleText.textContent = "切换: 扮演抓捕者";
                    switchRoleButton.className = switchRoleButton.className.replace('text-purple-600', 'text-pink-600').replace('bg-purple-50', 'bg-pink-50');
                }
                // Re-render icons if needed (Lucide handles this automatically usually, but we might need to trigger it if we changed innerHTML)
            }

            function switchRole() {
                playerRole = playerRole === 'catcher' ? 'cat' : 'catcher';
                initGame();
            }

            function resize() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                
                const contentWidth = GRID_SIZE * (RADIUS * 2 + GAP) + RADIUS;
                const scale = canvas.width / (contentWidth + 40);
                
                ctx.setTransform(scale, 0, 0, scale, 20, 20);
            }

            function draw() {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();

                const isDark = document.documentElement.classList.contains('dark');
                const dotColor = isDark ? '#374151' : '#e5e7eb';
                const blockedColor = isDark ? '#9ca3af' : '#6b7280';
                const catColor = playerRole === 'cat' ? '#ec4899' : '#ef4444'; // Pink if player is cat, Red otherwise

                // Draw Dots
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const dot = dots[y][x];
                        const px = getPixelPos(x, y);
                        
                        ctx.beginPath();
                        ctx.arc(px.x, px.y, RADIUS, 0, Math.PI * 2);
                        ctx.fillStyle = dot.blocked ? blockedColor : dotColor;
                        ctx.fill();
                        ctx.closePath();
                    }
                }

                // Highlight valid moves for Player Cat
                if (playerRole === 'cat' && gameState === 'playing' && !isAiTurn) {
                    const neighbors = getNeighbors(catPos.x, catPos.y);
                    for (let n of neighbors) {
                        if (!dots[n.y][n.x].blocked) {
                            const px = getPixelPos(n.x, n.y);
                            ctx.beginPath();
                            ctx.arc(px.x, px.y, RADIUS, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(236, 72, 153, 0.4)'; // Pink Highlight
                            ctx.fill();
                        }
                    }
                }

                // Draw Cat
                const catPx = getPixelPos(catPos.x, catPos.y);
                ctx.beginPath();
                ctx.arc(catPx.x, catPx.y, RADIUS * 0.8, 0, Math.PI * 2);
                ctx.fillStyle = catColor;
                ctx.fill();
                
                // Draw Cat Face
                ctx.fillStyle = 'white';
                ctx.beginPath(); ctx.arc(catPx.x - 4, catPx.y - 2, 2.5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(catPx.x + 4, catPx.y - 2, 2.5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(catPx.x, catPx.y + 2, 1.5, 0, Math.PI * 2); ctx.fill();
            }

            function getPixelPos(x, y) {
                const offsetX = (y % 2) * (RADIUS + GAP / 2);
                const px = x * (RADIUS * 2 + GAP) + offsetX;
                const py = y * (RADIUS * 2 + GAP) * 0.866;
                return { x: px, y: py };
            }

            function getGridPos(clickX, clickY) {
                const contentWidth = GRID_SIZE * (RADIUS * 2 + GAP) + RADIUS;
                const scale = canvas.width / (contentWidth + 40);
                
                const relativeX = (clickX - 20) / scale;
                const relativeY = (clickY - 20) / scale;

                let minDist = Infinity;
                let closest = null;

                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const px = getPixelPos(x, y);
                        const dist = Math.sqrt((px.x - relativeX) ** 2 + (px.y - relativeY) ** 2);
                        if (dist < RADIUS + 2 && dist < minDist) {
                            minDist = dist;
                            closest = { x, y };
                        }
                    }
                }
                return closest;
            }

            function getNeighbors(x, y) {
                const neighbors = [];
                const isOdd = y % 2 !== 0;
                const directions = isOdd ? 
                    [[0, -1], [1, -1], [-1, 0], [1, 0], [0, 1], [1, 1]] :
                    [[-1, -1], [0, -1], [-1, 0], [1, 0], [-1, 1], [0, 1]];

                for (let dir of directions) {
                    const nx = x + dir[0];
                    const ny = y + dir[1];
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                        neighbors.push({ x: nx, y: ny });
                    }
                }
                return neighbors;
            }

            function findShortestPath(start) {
                const queue = [{ x: start.x, y: start.y, path: [] }];
                const visited = new Set();
                visited.add(`${start.x},${start.y}`);

                while (queue.length > 0) {
                    const { x, y, path } = queue.shift();

                    if (x === 0 || x === GRID_SIZE - 1 || y === 0 || y === GRID_SIZE - 1) {
                        return path;
                    }

                    const neighbors = getNeighbors(x, y);
                    for (let n of neighbors) {
                        if (!dots[n.y][n.x].blocked && !visited.has(`${n.x},${n.y}`)) {
                            visited.add(`${n.x},${n.y}`);
                            queue.push({ x: n.x, y: n.y, path: [...path, { x: n.x, y: n.y }] });
                        }
                    }
                }
                return null;
            }

            // --- AI Logic ---

            function aiMoveCat() {
                const path = findShortestPath(catPos);
                
                if (path && path.length > 0) {
                    catPos = path[0];
                    if (isEdge(catPos)) {
                        endGame('cat_win');
                    }
                } else {
                    // No path to edge, move randomly to prolong
                    const neighbors = getNeighbors(catPos.x, catPos.y);
                    const available = neighbors.filter(n => !dots[n.y][n.x].blocked);
                    
                    if (available.length === 0) {
                        endGame('catcher_win');
                    } else {
                        const randomMove = available[Math.floor(Math.random() * available.length)];
                        catPos = randomMove;
                    }
                }
                draw();
                isAiTurn = false;
            }

            function aiPlaceBlock() {
                const path = findShortestPath(catPos);
                let blockTarget = null;

                if (path && path.length > 0) {
                    // Smart Block: Block the immediate next step
                    // This is simple but effective
                    blockTarget = path[0];
                } else {
                    // Cat is trapped, just fill random available spots to finish it
                    // Or try to block neighbors of cat
                    const neighbors = getNeighbors(catPos.x, catPos.y);
                    const available = neighbors.filter(n => !dots[n.y][n.x].blocked);
                    if (available.length > 0) {
                        blockTarget = available[Math.floor(Math.random() * available.length)];
                    } else {
                        // All blocked, wait for win check
                    }
                }

                if (blockTarget && !dots[blockTarget.y][blockTarget.x].blocked) {
                    dots[blockTarget.y][blockTarget.x].blocked = true;
                    // Check if cat is now completely trapped (no moves)
                    const neighbors = getNeighbors(catPos.x, catPos.y);
                    const available = neighbors.filter(n => !dots[n.y][n.x].blocked);
                    if (available.length === 0) {
                        endGame('catcher_win');
                    }
                }
                draw();
                isAiTurn = false;
            }

            function isEdge(pos) {
                return pos.x === 0 || pos.x === GRID_SIZE - 1 || pos.y === 0 || pos.y === GRID_SIZE - 1;
            }

            function endGame(result) {
                gameState = result === 'cat_win' ? 'lose' : 'win'; // Default perspective (Catcher)
                
                if (playerRole === 'catcher') {
                    if (result === 'cat_win') {
                        showMessage('小猫跑掉了！', 'bg-red-500');
                        gameState = 'lose';
                    } else {
                        showMessage('你抓住了小猫！', 'bg-green-500');
                        gameState = 'win';
                    }
                } else {
                    // Player is Cat
                    if (result === 'cat_win') {
                        showMessage('你逃脱了！', 'bg-green-500');
                        gameState = 'win';
                    } else {
                        showMessage('你被抓住了！', 'bg-red-500');
                        gameState = 'lose';
                    }
                }
            }

            function showMessage(text, colorClass) {
                messageText.textContent = text;
                // Reset classes
                messageText.className = `text-white font-bold text-xl px-6 py-3 rounded-full shadow-lg transform transition-transform duration-300 ${colorClass}`;
                messageEl.classList.remove('opacity-0', 'pointer-events-none');
                messageEl.querySelector('span').classList.remove('scale-0');
                messageEl.querySelector('span').classList.add('scale-100');
            }

            function hideMessage() {
                messageEl.classList.add('opacity-0', 'pointer-events-none');
                messageEl.querySelector('span').classList.add('scale-0');
                messageEl.querySelector('span').classList.remove('scale-100');
            }

            // Input Handling
            canvas.addEventListener('click', (e) => {
                if (gameState !== 'playing' || isAiTurn) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const gridPos = getGridPos(x, y);
                if (!gridPos) return;

                if (playerRole === 'catcher') {
                    const dot = dots[gridPos.y][gridPos.x];
                    if (!dot.blocked && (gridPos.x !== catPos.x || gridPos.y !== catPos.y)) {
                        dot.blocked = true;
                        draw();
                        
                        // Check if blocking caused instant win (rare but possible)
                        const neighbors = getNeighbors(catPos.x, catPos.y);
                        const available = neighbors.filter(n => !dots[n.y][n.x].blocked);
                        if (available.length === 0) {
                            endGame('catcher_win');
                        } else {
                            isAiTurn = true;
                            setTimeout(aiMoveCat, 200);
                        }
                    }
                } else {
                    // Player is Cat
                    // Check if clicked tile is neighbor and not blocked
                    const neighbors = getNeighbors(catPos.x, catPos.y);
                    const isNeighbor = neighbors.some(n => n.x === gridPos.x && n.y === gridPos.y);
                    const dot = dots[gridPos.y][gridPos.x];

                    if (isNeighbor && !dot.blocked) {
                        catPos = gridPos;
                        draw();

                        if (isEdge(catPos)) {
                            endGame('cat_win');
                        } else {
                            isAiTurn = true;
                            setTimeout(aiPlaceBlock, 200);
                        }
                    }
                }
            });

            resetButton.addEventListener('click', initGame);
            switchRoleButton.addEventListener('click', switchRole);
            
            window.addEventListener('resize', () => {
                resize();
                draw();
            });

            // Start
            initGame();
        })();
    </script>
</body>
</html>